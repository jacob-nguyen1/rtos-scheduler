#include "Job.h"
#include <random>
#include <iostream>
#include <algorithm>

Job::Job(int id, std::string task, int priority, int executionTime, int arrivalTime, int deadlineWindow) :
    jobID(id),
    task(task),
    priority(priority),
    executionTime(executionTime),
    arrivalTime(arrivalTime),
    remainingTime(executionTime),
    deadline(arrivalTime + deadlineWindow),
    completionTime(-1),
    missedDeadline(false)
    {
        state = JobState::WAITING;
    }

void Job::markCompleted(int currentTime) {
    completionTime = currentTime;
    missedDeadline = (completionTime > deadline);
    state = JobState::COMPLETED;
}

float Job::progress() const{
    return 1.0f - (float(remainingTime) / executionTime);
}


//DATA RANDOMLY GENERATED BY GPT-5

static std::random_device rd;
static std::mt19937 gen(rd());
//static std::mt19937 gen(42) fixed seed for debugging

static int randInt(int min, int max) {
    std::uniform_int_distribution<> dist(min, max);
    return dist(gen);
}

std::vector<Job> generateJobs(int simTime) {
    std::vector<Job> jobs;
    int id = 0;

    struct TaskProfile {
        std::string name;
        int priority;
        int basePeriod;
        int baseExec;
        float deadlineFactor;
    };

    std::vector<TaskProfile> templates = {
        {"ABS_Control",        0,  10, 3, 3.5f},
        {"FuelInjection",      1,  20, 3, 3.5f},
        {"ThrottleControl",    2,  30, 5, 3.5f},
        {"BrakePressure",      3,  50, 5, 3.5f},
        {"TransmissionCtrl",   4,  80, 8, 4.0f},
        {"DashboardUpdate",    5, 100,12, 4.0f},
        {"Diagnostics",        6, 200,10, 5.0f},
        {"DataLogging",        7, 250,20, 5.0f},
    };

    // ---- Step A: compute nominal utilization ----
    double rhoNominal = 0.0;
    for (auto& tpl : templates)
        rhoNominal += static_cast<double>(tpl.baseExec) / tpl.basePeriod;

    // ---- Step B: scale all periods so target ρ ≈ 0.80 ----
    const double targetUtil = 1.5;
    if (rhoNominal > 0.0) {
        double scale = targetUtil / rhoNominal;   //smaller load ⇒ longer periods
        for (auto& tpl : templates)
            tpl.basePeriod = static_cast<int>(tpl.basePeriod / scale + 0.5);
        // (Divide by scale because scale<1 makes periods larger)
    }

    // ---- Step C: generate jobs ----
    for (const auto& tpl : templates) {
        int nextArrival = randInt(0, tpl.basePeriod / 2);
        while (nextArrival < simTime) {
            int jitter = randInt(-tpl.basePeriod / 10, tpl.basePeriod / 10);
            int arrival = std::max(0, nextArrival + jitter);

            int exec = std::max(1, randInt(
                static_cast<int>(tpl.baseExec * 0.9),
                static_cast<int>(tpl.baseExec * 1.1)
            ));

            int window = std::max(exec + 1, randInt(
                static_cast<int>(tpl.deadlineFactor * exec * 1.0),
                static_cast<int>(tpl.deadlineFactor * exec * 1.3)
            ));

            jobs.emplace_back(id++, tpl.name, tpl.priority, exec, arrival, window);

            int nextGap = randInt(
                static_cast<int>(tpl.basePeriod * 0.9),
                static_cast<int>(tpl.basePeriod * 1.05)
            );
            nextArrival += nextGap;
        }
    }

    std::sort(jobs.begin(), jobs.end(),
              [](const Job& a, const Job& b) { return a.arrivalTime < b.arrivalTime; });

    // ---- Step D: report final average utilization ----
    double totalExec = 0;
    for (auto& j : jobs) totalExec += j.executionTime;
    double util = totalExec / simTime;
    std::cout << "Average utilization after scaling ≈ " << util << std::endl;

    return jobs;
}
